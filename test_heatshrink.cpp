// test_heatshrink.cpp : Ce fichier contient la fonction 'main'. L'exécution du programme commence et se termine à cet endroit.
//

#include <iostream>
#include <array>
#include "heatshrink_encoder.h"
#include "heatshrink_decoder.h"
#include <chrono>

template<typename T>
bool compareArray(T* a, std::size_t sizeA, T* b, std::size_t sizeB) {
	if (sizeA != sizeB) {
		std::cout << "size does not match, "<< sizeA << "!=" << sizeB << std::endl;
		return false;
	}
	for (auto i = 0U; i < sizeA; i++) {
		if (a[i] != b[i]) {
			std::cout << "data at: " << i << "does not match " << a[i] << "!=" << b[i] << std::endl;
			return false;
		}
	}
	std::cout << "data matched" << std::endl;
	return true;
}

int main()
{
	static heatshrink_encoder encoder;
	static heatshrink_decoder decoder;

	std::cout << "size of encoder is: " << sizeof(encoder) << std::endl;
	char data[] = {
	0x6c, 0x6f, 0x71, 0x73, 0x75, 0x78, 0x7a, 0x7c, 0x7e, 0x80, 0x83, 0x85, 0x88, 0x8c,
	0x8f, 0x92, 0x96, 0x99, 0x9d, 0xa1, 0xa5, 0xa9, 0xae, 0xb2, 0xb7, 0xbb, 0xc0, 0xc5,
	0xc9, 0xcc, 0xcf, 0xd1, 0xd3, 0xd4, 0xd5, 0xd6, 0xd6, 0xd7, 0xd8, 0xd8, 0xd9, 0xd9,
	0xd9, 0xda, 0xda, 0xdb, 0xdb, 0xdc, 0xdc, 0xdc, 0xdd, 0xdd, 0xde, 0xde, 0xde, 0xdf,
	0xdf, 0xdf, 0xe0, 0xe0, 0xe0, 0xe1, 0xe1, 0xe1, 0xe2, 0xe2, 0xe2, 0xe2, 0xe3, 0xe3,
	0xe3, 0xe3, 0xe4, 0xe4, 0xe4, 0xe4, 0xe4, 0xe5, 0xe5, 0xe5, 0xe5, 0xe5, 0xe6, 0xe6,
	0xe6, 0xe6, 0xe6, 0xe6, 0xe7, 0xe7, 0xe7, 0xe7, 0xe7, 0xe7, 0xe7, 0xe8, 0xe8, 0xe8,
	0xe8, 0xe8, 0xe8, 0xe8, 0xe8, 0xe9, 0xe9, 0xe9, 0xe9, 0xe9, 0xe9, 0xe9, 0xe9, 0xe9,
	0xe9, 0xe9, 0xe9, 0xe9, 0xe9, 0xea, 0xea, 0xea, 0xea, 0xea, 0xea, 0xea, 0xea, 0xea,
	0xea, 0xea, 0xea, 0xea, 0xea, 0xea, 0xea, 0xea, 0xea, 0xea, 0xea, 0xea, 0xea, 0xea,
	0xea, 0xea, 0xea, 0xea, 0xea, 0xea, 0xea, 0xea, 0xea, 0xea, 0xea, 0xea, 0xea, 0xea,
	0xea, 0xea, 0xea, 0xea, 0xea, 0xea, 0xea, 0xea, 0xea, 0xea, 0xea, 0xea, 0xea, 0xea,
	0xeb, 0xeb, 0xeb, 0xe8, 0xe6, 0xe4, 0xe2, 0xe0, 0xdf, 0xdd, 0xdc, 0xdb, 0xda, 0xd9,
	0xd8, 0xd8, 0xd8, 0xd8, 0xd8, 0xd8, 0xd8, 0xd8, 0xd8, 0xd8, 0xd8, 0xd7, 0xd7, 0xd7,
	0xd7, 0xd7, 0xd7, 0xd7, 0xd7, 0xd7, 0xd7, 0xd7, 0xd7, 0xd7, 0xd7, 0xd7, 0xd7, 0xd7,
	0xd7, 0xd7, 0xd7, 0xd7, 0xd7, 0xd7, 0xd7, 0xd7, 0xd7, 0xd7, 0xd7, 0xd7, 0xd7, 0xd7,
	0xd7, 0xd7, 0xd8, 0xd8, 0xd8, 0xd7, 0xd7, 0xd6, 0xd6, 0xd6, 0xd6, 0xd6, 0xd6, 0xd6,
	0xd6, 0xd6, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd4, 0xd4, 0xd4, 0xd4, 0xd1,
	0xce, 0xcc, 0xca, 0xc7, 0xc3, 0xc0, 0xbd, 0xba, 0xb7, 0xb4, 0xb2, 0xaf, 0xac, 0xa9,
	0xa7, 0xa5, 0xa2, 0xa0, 0x9e, 0x9c, 0x9a, 0x98, 0x96, 0x94, 0x92, 0x91, 0x8f, 0x8e,
	0x8c, 0x8b, 0x89, 0x88, 0x86, 0x85, 0x84, 0x83, 0x81, 0x80, 0x7f, 0x7e, 0x7d, 0x7c,
	0x7b, 0x7a, 0x79, 0x78, 0x77, 0x77, 0x76, 0x75, 0x74, 0x73, 0x71, 0x62, 0x62, 0x62,
	0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62,
	0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62,
	0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62,
	0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62,
	0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62,
	0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62,
	0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62 };

	auto& toCompress = data;

	std::array<int8_t, sizeof(toCompress)> dataDelta;
	float m_previousValue = 1013.f;
	for (auto i = 0U; i < sizeof(toCompress); i++) {
		auto value = static_cast<float>(toCompress[i])*10;
		dataDelta[i] = static_cast<int8_t>(value - m_previousValue);
		m_previousValue = value;
	}
	uint32_t polled = 0;
	uint32_t sunk = 0;
	uint64_t count = 0;

	std::array<uint8_t, 2000> result;
	std::array<uint8_t, 2000> deflate;
	uint64_t compressedSize;
	HSE_sink_res sinkResult;
	HSE_poll_res pollResult;
	heatshrink_encoder_reset(&encoder);
	heatshrink_decoder_reset(&decoder);
	HSD_poll_res decoderPollResult;
	HSD_sink_res decoderSinkResult;
	auto start = std::chrono::system_clock::now();
	auto i = 0U;
	while(sunk < dataDelta.max_size()) {
		auto encodeResult = heatshrink_encoder_sink(&encoder, reinterpret_cast<uint8_t*>(&dataDelta[sunk]), i - sunk+1, &count);
		sunk += count;
		if (i < dataDelta.max_size() - 1) {
			i++;
		}
		std::cout << sunk << ", "<< count << ", " << encodeResult << ", " << i << std::endl;
	}
	auto finishResult = heatshrink_encoder_finish(&encoder);
	polled = 0;
	count = 0;
	do {
		pollResult = heatshrink_encoder_poll(&encoder, &result[polled], result.max_size() - polled, &count);
		polled += count;
	} while (pollResult == HSER_POLL_MORE);
	auto end = std::chrono::system_clock::now();
	std::cout << "time " << static_cast<uint64_t>(std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count()) << std::endl;

	compressedSize = polled;
	std::cout << "compressed data: " << std::endl;
	for (auto i = 0U; i < polled; i++) {
		std::cout << static_cast<int32_t>(result[i]) << std::endl;
	}

	sunk = 0;
	polled = 0;
	count = 0;
	while (sunk < compressedSize) {
		heatshrink_decoder_sink(&decoder, &result[sunk], compressedSize - sunk, &count);
		sunk += count;
		do {
			decoderPollResult = heatshrink_decoder_poll(&decoder, &deflate[polled], deflate.max_size() - polled, &count);
			polled += count;
		} while (pollResult == HSDR_POLL_MORE);
		auto decodeFinishResult = heatshrink_decoder_finish(&decoder);
	}


	auto match = compareArray(reinterpret_cast<uint8_t*>(dataDelta.data()),dataDelta.max_size(), deflate.data(), polled);
	std::cout << "compression delta finished, started size: " << dataDelta.max_size() << ", compressed size: " << compressedSize << std::endl;
}
